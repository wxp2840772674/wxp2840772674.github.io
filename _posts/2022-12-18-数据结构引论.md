# 数据结构与算法分析 C语言描述

（美）Mark Allen Weiss 著，冯舜玺 译

机械工业出版社

1.  数据结构与算法的讨论内容：在庞大的数据量的情况下，如何使用更快的速度来完成我们的需求

    **例子1：在一组N个数中确定第k个最大者：**

    （1） 按照顺序依次读入*N*个数据，再使用排序算法，如冒泡排序，返回第*k*个最大值。

    （2） 先读入前*k*个数据，进行排序。接着逐个读入数据，如果比这第*k*个数据大，则将其放在相应的位置，并挤掉剩下的元素。否则忽略。算法终止时，返回第*k*个元素。

    （3） 后面的章节提到。

    **例子2：从表中找出单词，这些单词可能是由水平、垂直或以对角线任何方向放置的。**

|   | 1 | 2 | 3 | 4 |
|---|---|---|---|---|
| 1 | t | h | i | s |
| 2 | w | a | t | s |
| 3 | o | a | h | g |
| 4 | f | g | d | t |

1.  对每个单词，我们检查每一个有序三元组（行、列、方向），验证是否由单词存在（需要大量的for循环，但是直观）
2.  对于同一每一个尚未进行到字谜最后的有序四元组（行、列、方向、字符数）。我们可以测试所指的单词是否再单词表中，虽然可能要大量的for循环，但是我们知道要多少字符。所以这也是一个比较直观的算法。

    上述方法虽然可行度不高，但是我们还是有办法的。

3.  需要用到的一些数学知识：
   
    （1） 指数运算；
    
    （2）对数运算（换底公式等定理）

    一些结论：$log⁡(A/B)=log⁡A-log⁡B$；$log⁡(A^B)=B log⁡A$，$log⁡(X)<X (X<0)$。

    一些常见的对数:

    (3)  级数：
$$
∑_{i=0}^N  2^i =2^{N+1}-1
$$
    和
$$
∑_{i=0}^N A^i = \frac {A^{N+1}-1}{A-1}
$$
    当
$$
∑_{i=0}^NA^i <\frac{1}{1-A}
$$
    算数级数：
$$
∑_{i=1}^Ni=\frac{N(N+1)}{2}≈\frac{N^2}{2}
$$
    一些不常见的公式：
$$
∑_{i=1}^Ni^2=\frac{N(N+1)(2N+1)}{6}≈\frac{N^3}{3}
$$
$$
∑_{i=1}^Ni^k≈\frac{N^{k+1}}{|k+1|}(k \neq -1)
$$
   第二个公式中，当k=-1不成立，但是，我们可以使用下面的公式，求当时的值，该公式常用于计算机科学中。其中，数叫做调和数，其和为调和和。该公式的近似误差趋向于欧拉常数（$ \gamma \approx 0.57721566 $）



    一般的代数运算：

1.  模运算：一个定理：如果*N*整除，则*A*与*B*模*N*同余记作。这个同等号的情形。
2.  一些证明方法：

    **归纳法证明**（斐波那契数列中时，；以及）

    通过**反例证明**某个公式不成立（，这个是不成立的）

    **反证法证明**（例子：。其中，到为依序排列的素数，*N*也是素数）

3.  递归简论：
4.  在C语言中，允许函数递归执行。C提供递归方法的是遵循递归思想的一种企图。这意味着不是所有的数学递归函数都能被递归运行。
5.  递归函数的构成两个基本法则：基准情形、不断推进。
6.  递归并不是循环逻辑。（后文提到）
7.  递归调用在处理上与其他调用并不相同，但是递归调用会被反复进行，直到基准情形出现。

    **例子：打印输出数：给定一个正整数，并将其打印出来。**

    递归实现过程（我们假设PrintDigit()函数为递归的基准情形）：
```C
void PrintOut(unsigned int N)
{
    if(N >= 10)
    PrintOut(N / 10);
    PrintDigit(N % 10);
    }
```
    这个过程并没有高效地去做这些事情，因为本来我们可以不用mod操作（由于耗费巨大）

1.  递归算法的数学根据就是归纳法。
2.  递归函数的第三、四个基本准则。设计法则：所有递归调用都能准确运行。合成效益法则：在求解一个问题的同一实例，切勿在不同的递归调用中做重复性的工作。
3.  递归的主要问题：隐含的簿记开销。

总结：对于算法，首先是正确性，其次是判断好坏。
